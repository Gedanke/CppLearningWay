# 区别篇

---

## C 和 C++ 区别

* C++ 是面向对象的语言，而 C 是面向过程的语言
* C++ 中的 xxx 取代了 C 中的 xxx
    * C++ 中的 `new` 和 `delete` 内存分配的运算符，取代了 C 中的 `malloc` 和 `free`
    * C++ 中的字符串类取代了标准 C 函数库头文件中的字符数组处理函数，C 中是没有字符串类型
    * C++ 中 `iostream` 类库替代了标准 C 中的 `stdio` 函数库
    * C++ 中的 `try/catch/throw` 异常处理机制取代了标准 C 中的 `setjmp()` 和 `longjmp()` 函数
* C++ 引入了 xxx，而 C 中没有或者不行
    * C++ 引入引用的概念，而 C 中没有
    * C++ 引入类的概念，而 C 中没有
    * C++ 引入函数重载的特性，而 C 中没有
    * C++ 引入了很多关键字，如：bool、using、dynamic_cast、namespace，而 C 中没有
    * C++ 中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而 C 语言中，必须要在函数开头部分。而且 C++ 不允许重复定义变量

---

## C++ 和 python 区别

* python 是脚本语言，是解释执行的，而 C++ 是编译语言，编译后在特定平台运行的，不他平台有不同编译器，不同的头文件等等。python 跨平台很方便，但效率不及 C++。当然 python 有些库在不同平台下的表现也会有一定差异，但总体比 C++ 好一些
* python 使用缩进来区分不同的代码块，C++ 使用花括号来区分
* C++ 定义变量需指定其类型，而 python 不需要，其基本数据类型只有数字，布尔值，字符串，列表，元组等等，当然 C++ 也可以使用 `auto` 让编译器自动推导
* python 库函数很多，安装，使用起来都比 C++ 方便得多

---

## C++ 与 Java 区别

* Java 语法更为简洁；完全面向对象，它的可移植性强
* Java 没有指针的概念，引入了真正的数组。不同于 C++ 中利用指针实现的“伪数组”，Java 引入了真正的数组，摒弃了指针这个概念，减少了 C++ 程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题。其实 STL 中的 `[]` 运算符访问元素越界编译器不会报错，而 `at()` 方法则会进行检查
* C++ 几乎可以在所有操作系统上运行，但是需要不同的编码，这一点不如 Java，只编写一次代码，到处运行，例如 C++ 的 `float` 与 `double` 在 windows 与 linux 上储存的空间不一样，Java 则是统一的
* Java 用接口(`Interface`)技术取代C++程序中的抽象类。接口与抽象类有同样的功能，但是省却了在实现和维护上的复杂性
* C++ 用析构函数回收垃圾，写 C 和 C++ 程序时一定要注意内存的申请和释放，主要是 `new` 操作，在堆上申请内存，而忘了释放或者重复释放；Java 没有指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题，但依然会有内存方面问题，如常见的空指针异常
* Java 在桌面程序上不如 C++，C++ 可以直接编译成 `exe` 文件，指针是 C++ 的优势，可以直接对内存的操作，但同时具有危险性
* Java 在 Web 应用上具有 C++ 无可比拟的优势，具有丰富多样的框架；对于底层程序的编程以及控制方面的编程，C++ 很灵活，因为有句柄的存在

---

## a 和 &a 区别

假设数组 `int a[5]; int (*p)[5] = &a;`，其中：

* `a` 是数组名，是数组首元素地址，`+1` 表示地址值加上一个 `int` 类型的大小，如果 `a` 的值是 `0x11111111`，加 1 操作后变为 `0x11111115`。`*(a + 1) = a[1]`
* `&a` 是数组的指针，其类型为 `int (*)[5]`(前面提到的数组指针)，其加 1 时，系统会认为是数组首地址加上整个数组的偏移(5 个 `int` 型变量)，值为数组 `a` 尾元素后一个元素的地址
* 若 `(int *)p` ，此时输出 `*p` 时，其值为 `a[0]` 的值，因为被转为 `int *` 类型，解引用时按照 `int` 类型大小来读取

---

## 指针和引用区别

* 指针是一个变量，存储的是地址，引用跟原变量是同一个东西，只是个别名
* 指针可以有多级，引用只有一级
* 指针可以为空，先定义后初始化，引用不能为 `NULL` 且在定义时必须初始化
* 指针在初始化后可以改变指向，而引用在初始化之后不可改变指向
* `sizeof` 指针得到的是本指针的大小，`sizeof` 引用得到的是引用所指向变量的大小
* 指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，指针需要被解引用才可以对对象进行操作，在函数中改变这个变量的指向不影响实参，而引用却可以，直接对引用的修改都会改变引用所指向的对象
* 引用本质是一个指针，同样会占 4 字节内存；指针是具体变量，需要占用存储空间，具体情况还要具体分析
* 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针
* 指针和引用使用 `++` 运算符的意义不一样
* 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露

---

## 常量指针和指针常量区别

区分的时候，看 `const` 与 `*` 的前后位置

* 指针常量是一个指针，指向一个只读变量，也就是后面所指明的 `int const` 和 `const int`，都是一个常量，可以写作 `int const *p` 或 `const int *p`
* 常量指针是一个不能给改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值就不能在改变了，即不能中途改变指向，如 `int *const p`，引用就是常量指针

---

## 堆区和栈区区别

* 申请方式
    * 栈资源由编译器自动管理，无需程序员手动处理
    * 堆中资源由程序员开辟与释放，存放函数的参数值，局部变量的值
* 内存管理机制，连续空间和连续空间的区别
    * 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出
    * 系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序(大多数系统会在这块内存空间首地址记录本次分配的大小，这样 `delete` 才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中)
* 空间大小
    * 栈是一块连续的内存区域，大小是操作系统预定好的，默认是 4M，可以通过 `ulimit -a` 查看，由 `ulimit -s` 修改
    * 堆是不连续的内存区域，堆大小受限于计算机系统中有效的虚拟内存，所以堆的空间比较灵活，比较大
* 碎片问题
    * 对于栈，它是类似于数据结构上的栈，进出一一对应，不会产生碎片
    * 对于堆，频繁的 `new/delete` 会造成大量碎片，使程序效率降低
* 生长方向
    * 栈向下，向低地址方向增长
    * 堆向上，向高地址方向增长
* 分配方式
    * 栈有静态分配和动态分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现
        * 静态分配由编译器完成(如局部变量分配)
        * 动态分配由 `alloca` 函数分配
    * 堆只是动态分配
* 分配效率
    * 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门寄存器存放栈地址，栈操作有专门指令
    * 堆由 C/C++ 函数库提供，机制很复杂。所以堆的效率比栈低很多

---

## 述队列和栈区别

队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同

* 队列是“先进先出”
* 栈是 “后进先出”。

注意：堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域

---

## strlen 和 sizeof 区别

* `sizeof` 是运算符，并不是函数，结果在编译时得到而非运行中获得；`strlen` 是字符处理的库函数
* `sizeof` 参数可以是任何数据的类型或者数据(`sizeof` 参数不退化)；`strlen` 的参数只能是字符指针且结尾是 `\0` 的字符串
* 因为 `sizeof` 值在编译时确定，所以不能用来得到动态分配(运行时分配)存储空间的大小

---

## malloc 和 new 区别

* `malloc` 和 `free` 是标准库函数，支持覆盖；`new` 和 `delete` 是运算符，不重载
* `malloc` 仅仅分配内存空间，`free` 仅仅回收空间，不具备调用构造函数和析构函数功能，用 `malloc` 分配空间存储类的对象存在风险；`new` 和 `delete` 除了分配回收功能外，还会调用构造函数和析构函数
* `malloc` 和 `free` 返回的是 `void` 类型指针(必须进行类型转换)，`new` 和 `delete` 返回的是具体类型指针

---

## new/delete 和 malloc/free 区别

相同点：都可用于内存的动态申请和释放

不同点：

* 前者是 C++ 运算符，后者是 C/C++ 语言标准库函数
* `new` 自动计算要分配的空间大小，`malloc` 需要手工计算
* `new` 是类型安全的，`malloc` 不是
* `new` 调用名为 `operator new` 的标准库函数分配足够空间并调用相关对象的构造函数，`delete` 对指针所指对象运行适当的析构函数；然后通过调用名为 `operator delete` 的标准库函数释放该对象所用内存。后者均没有相关调用
* 后者需要库文件支持，前者不用
* `new` 是封装了 `malloc`，直接 `free` 不会报错，但是这只是释放内存，而不会析构对象

既然有了 `malloc/free`，C++ 中为什么还需要 `new/delete` 呢？直接用 `malloc/free` 不好吗？

`malloc/free` 和 `new/delete` 都是用来申请内存和回收内存的
* 在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而 `malloc/free` 是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给 `malloc/free`，所以 `new/delete` 是必不可少的

---

## 宏定义和函数区别

* 宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数
* 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值
* 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型
* 宏定义不要在最后加分号

---

## 宏定义和 typedef 区别

* 宏主要用于定义常量及书写复杂的内容；`typedef` 主要用于定义类型别名
* 宏替换发生在编译阶段之前，属于文本插入替换；`typedef` 是编译的一部分
* 宏不检查类型；`typedef` 会检查数据类型
* 宏不是语句，不在在最后加分号；`typedef` 是语句，要加分号标识结束

注意对指针的操作，`typedef char * p_char` 和 `#define p_char char *` 区别巨大

---

## 变量声明和定义区别

* 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间
* 相同变量可以在多处声明(外部变量 `extern`)，但只能在一处定义

---

## C 和 C++ struct 区别

C 语言中：`struct` 是用户自定义数据类型(UDT)；C++ 中 `struct` 是抽象数据类型(ADT)，支持成员函数的定义(C++ 中的 struct 能继承，能实现多态)

C 中 `struct` 是没有权限设置的，且 `struct` 中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数

C++ 中，`struct` 增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为 `public`(为了与 C 兼容)

`struct` 作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在 C 中必须在结构标记前加上 `struct`，才能做结构类型名(`typedef struct StructName{}Name;` 除外)；C++ 中结构体标记(结构体名)可以直接作为结构体类型名使用，此外结构体 `struct` 在 C++ 中被当作类的一种特例

---

## struct 和 class 区别

相同点

* 两者都拥有成员函数、公有和私有部分
* 任何可以使用 `class` 完成的工作，同样可以使用 `struct` 完成

不同点

* 两者中如果不对成员不指定公私有，`struct` 默认是公有的，`class` 则默认是私有的
* `class` 默认是 `private` 继承，而 `struct` 默认是 `public` 继承

---

## define 宏定义和 const 区别

编译阶段

* `define` 是在编译的预处理阶段起作用，而 `const` 是在编译、运行的时候起作用

安全性

* `define` 只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错
* `const` 常量有数据类型，编译器可以对其进行类型安全检查

内存占用

* `define` 只是将宏名称进行替换，在内存中会产生多分相同的备份。`const` 在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表
* 宏替换发生在编译阶段之前，属于文本插入替换；`const` 作用发生于编译过程中
* 宏不检查类型；`const` 会检查数据类型
* 宏定义的数据没有分配内存空间，只是插入替换掉；`const` 定义的变量只是值不能改变，但要分配内存空间

---

## 顶层 const 和底层 const

* 顶层 `const`：指的是 `const` 修饰的变量本身是一个常量，无法修改，指的是指针，就是 `*` 号的右边
* 底层 `const`：指的是 `const` 修饰的变量所指向的对象是一个常量，指的是所指变量，就是 `*` 号的左边

举个例子

```c
int a = 10;
int *const b1 = &a;       // 顶层 const，b1 本身是一个常量
const int *b2 = &a;       // 底层 const，b2 本身可变，所指的对象是常量
const int b3 = 20;        // 顶层 const，b3 是常量不可变
const int *const b4 = &a; // 前一个 const 为底层，后一个为顶层，b4 不可变
const int &b5 = a;        // 用于声明引用变量，都是底层 const
```
    
区分作用

* 执行对象拷贝时有限制，常量的底层 `const` 不能赋值给非常量的底层 `const`
* 使用命名的强制类型转换函数 `const_cast` 时，只能改变运算对象的底层 `const`

```c
const int a;
int const a;
const int *a;
int *const a;
```
    
* `int const a` 和 `const int a` 均表示定义常量类型 `a`
* `const int *a`，其中 `a` 为指向 `int` 型变量的指针，`const` 在 `*` 左侧，表示 `a` 指向不可变常量(看成 `const (*a)`，对引用加 `const`)
* `int *const a`，依旧是指针类型，表示 `a` 为指向整型数据的常指针(看成 `const(a)`，对指针 `const`)

---

## 数组名和指针区别

* 二者均可通过增减偏移量来访问数组中的元素
* 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作
* 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但 `sizeof` 运算符不能再得到原数组的大小了

---

## 拷贝初始化和直接初始化区别

* 当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下

```c
string str1("I am a string");  //语句1 直接初始化
string str2(str1);             //语句2 直接初始化，str1 是已经存在的对象，直接调用拷贝构造函数对 str2 进行初始化
string str3 = "I am a string"; //语句3 拷贝初始化，先为字符串 "I am a string" 创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造 str3
string str4 = str1;            //语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数
```
    
* 为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化了(语句1 和语句3 等价)，但是需要辨别两种情况
    * 当拷贝构造函数为 `private` 时：语句3 和语句4 在编译时会报错
    * 使用 `explicit` 修饰构造函数时：如果构造函数存在隐式转换，编译时会报错

---

## 初始化和赋值区别

对于简单类型来说，初始化和赋值没什么区别
对于类和复杂数据类型来说，有区别，举例如下：

```c
#include <iostream>

using namespace std;

class A
{
public:
    int num1;
    int num2;

public:
    A(int a = 0, int b = 0) : num1(a), num2(b){};
    A(const A &a){};
    // 重载 = 号操作符函数
    A &operator=(const A &a)
    {
        num1 = a.num1 + 1;
        num2 = a.num2 + 1;
        return *this;
    };
};
int main()
{
    A a(1, 1);
    A a1 = a; // 拷贝初始化操作，调用拷贝构造函数
    A b;
    b = a; // 赋值操作，对象 a 中，num1 = 1，num2 = 1；对象 b 中，num1 = 2，num2 = 2
    return 0;
}
```

---

## 重载、重写(覆盖)和隐藏的区别




---

## 浅拷贝和深拷贝的区别

* 浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误

* 深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的

```c
#include <iostream>
#include <string.h>
using namespace std;

class Student
{
private:
    int num;
    char *name;

public:
    Student()
    {
        name = new char(20);
        cout << "Student" << endl;
    }

    ~Student()
    {
        cout << "~Student " << &name << endl;
        delete name;
        name = NULL;
    }

    // 拷贝构造函数
    Student(const Student &s)
    {
        // 浅拷贝，当对象的 name 和传入对象的 name 指向相同的地址
        // name = s.name;
        // 深拷贝
        name = new char(20);
        memcpy(name, s.name, strlen(s.name));
        cout << "copy Student" << endl;
    }
};

int main()
{
    // 花括号让 s1 和 s2 变成局部对象，方便测试
    Student s1;
    Student s2(s1); // 复制对象

    // 浅拷贝
    /*
        Student
        copy Student
        ~Student 0x7fff616aa758
        ~Student 0x7fff616aa748
        free(): double free detected in tcache 2
        Aborted
    */

    // 深拷贝

    /*
        Student
        copy Student
        ~Student 0x7ffd37019ec8
        ~Student 0x7ffd37019eb8
    */

    return 0;
}
```

---

## 内联函数和宏定义区别

* 在使用时，宏只做简单字符串替换(编译前)。而内联函数可以进行参数类型检查(编译时)，且具有返回值
* 内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载
* 宏定义时要注意书写(参数要括起来)否则容易出现歧义，内联函数不会产生歧义
* 内联函数有类型检测、语法判断等功能，而宏没有

内联函数适用场景:

* 使用宏定义的地方都可以使用 `inline` 函数
* 作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率







---
