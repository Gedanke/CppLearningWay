# 区别篇

---

## C 和 C++ 的区别

* C++ 是面向对象的语言，而 C 是面向过程的语言
* C++ 中的 xxx 取代了 C 中的 xxx
    * C++ 中的 `new` 和 `delete` 内存分配的运算符，取代了 C 中的 `malloc` 和 `free`
    * C++ 中的字符串类取代了标准 C 函数库头文件中的字符数组处理函数，C 中是没有字符串类型
    * C++ 中 `iostream` 类库替代了标准 C 中的 `stdio` 函数库
    * C++ 中的 `try/catch/throw` 异常处理机制取代了标准 C 中的 `setjmp()` 和 `longjmp()` 函数
* C++ 引入了 xxx，而 C 中没有或者不行
    * C++ 引入引用的概念，而 C 中没有
    * C++ 引入类的概念，而 C 中没有
    * C++ 引入函数重载的特性，而 C 中没有
    * C++ 引入了很多关键字，如：bool、using、dynamic_cast、namespace，而 C 中没有
    * C++ 中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而 C 语言中，必须要在函数开头部分。而且 C++ 不允许重复定义变量

---

## C++ 和 python 的区别

* python 是脚本语言，是解释执行的，而 C++ 是编译语言，编译后在特定平台运行的，不他平台有不同编译器，不同的头文件等等。python 跨平台很方便，但效率不及 C++。当然 python 有些库在不同平台下的表现也会有一定差异，但总体比 C++ 好一些
* python 使用缩进来区分不同的代码块，C++ 使用花括号来区分
* C++ 定义变量需指定其类型，而 python 不需要，其基本数据类型只有数字，布尔值，字符串，列表，元组等等，当然 C++ 也可以使用 `auto` 让编译器自动推导
* python 库函数很多，安装，使用起来都比 C++ 方便得多

---

## C++ 与 Java 的区别

* Java 语法更为简洁；完全面向对象，它的可移植性强
* Java 没有指针的概念，引入了真正的数组。不同于 C++ 中利用指针实现的“伪数组”，Java 引入了真正的数组，摒弃了指针这个概念，减少了 C++ 程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题。其实 STL 中的 `[]` 运算符访问元素越界编译器不会报错，而 `at()` 方法则会进行检查
* C++ 几乎可以在所有操作系统上运行，但是需要不同的编码，这一点不如 Java，只编写一次代码，到处运行，例如 C++ 的 `float` 与 `double` 在 windows 与 linux 上储存的空间不一样，Java 则是统一的
* Java 用接口(`Interface`)技术取代C++程序中的抽象类。接口与抽象类有同样的功能，但是省却了在实现和维护上的复杂性
* C++ 用析构函数回收垃圾，写 C 和 C++ 程序时一定要注意内存的申请和释放，主要是 `new` 操作，在堆上申请内存，而忘了释放或者重复释放；Java 没有指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题，但依然会有内存方面问题，如常见的空指针异常
* Java 在桌面程序上不如 C++，C++ 可以直接编译成 `exe` 文件，指针是 C++ 的优势，可以直接对内存的操作，但同时具有危险性
* Java 在 Web 应用上具有 C++ 无可比拟的优势，具有丰富多样的框架；对于底层程序的编程以及控制方面的编程，C++ 很灵活，因为有句柄的存在

---

## a 和 &a 有什么区别

假设数组 `int a[5]; int (*p)[5] = &a;`，其中：

* `a` 是数组名，是数组首元素地址，`+1` 表示地址值加上一个 `int` 类型的大小，如果 `a` 的值是 `0x11111111`，加 1 操作后变为 `0x11111115`。`*(a + 1) = a[1]`
* `&a` 是数组的指针，其类型为 `int (*)[5]`(前面提到的数组指针)，其加 1 时，系统会认为是数组首地址加上整个数组的偏移(5 个 `int` 型变量)，值为数组 `a` 尾元素后一个元素的地址
* 若 `(int *)p` ，此时输出 `*p` 时，其值为 `a[0]` 的值，因为被转为 `int *` 类型，解引用时按照 `int` 类型大小来读取

---

## 指针和引用的区别

* 指针是一个变量，存储的是地址，引用跟原变量是同一个东西，只是个别名
* 指针可以有多级，引用只有一级
* 指针可以为空，先定义后初始化，引用不能为 `NULL` 且在定义时必须初始化
* 指针在初始化后可以改变指向，而引用在初始化之后不可改变指向
* `sizeof` 指针得到的是本指针的大小，`sizeof` 引用得到的是引用所指向变量的大小
* 指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，指针需要被解引用才可以对对象进行操作，在函数中改变这个变量的指向不影响实参，而引用却可以，直接对引用的修改都会改变引用所指向的对象
* 引用本质是一个指针，同样会占 4 字节内存；指针是具体变量，需要占用存储空间，具体情况还要具体分析
* 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针
* 指针和引用使用 `++` 运算符的意义不一样
* 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露

---

## 常量指针和指针常量区别

区分的时候，看 `const` 与 `*` 的前后位置

* 指针常量是一个指针，指向一个只读变量，也就是后面所指明的 `int const` 和 `const int`，都是一个常量，可以写作 `int const *p` 或 `const int *p`
* 常量指针是一个不能给改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值就不能在改变了，即不能中途改变指向，如 `int *const p`，引用就是常量指针

---

## 堆区和栈区的区别

* 申请方式
    * 栈资源由编译器自动管理，无需程序员手动处理
    * 堆中资源由程序员开辟与释放，存放函数的参数值，局部变量的值
* 内存管理机制，连续空间和连续空间的区别
    * 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出
    * 系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序(大多数系统会在这块内存空间首地址记录本次分配的大小，这样 `delete` 才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中)
* 空间大小
    * 栈是一块连续的内存区域，大小是操作系统预定好的，默认是 4M，可以通过 `ulimit -a` 查看，由 `ulimit -s` 修改
    * 堆是不连续的内存区域，堆大小受限于计算机系统中有效的虚拟内存，所以堆的空间比较灵活，比较大
* 碎片问题
    * 对于栈，它是类似于数据结构上的栈，进出一一对应，不会产生碎片
    * 对于堆，频繁的 `new/delete` 会造成大量碎片，使程序效率降低
* 生长方向
    * 栈向下，向低地址方向增长
    * 堆向上，向高地址方向增长
* 分配方式
    * 栈有静态分配和动态分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现
        * 静态分配由编译器完成(如局部变量分配)
        * 动态分配由 `alloca` 函数分配
    * 堆只是动态分配
* 分配效率
    * 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门寄存器存放栈地址，栈操作有专门指令
    * 堆由 C/C++ 函数库提供，机制很复杂。所以堆的效率比栈低很多

---

## 述队列和栈的区别

队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同

* 队列是“先进先出”
* 栈是 “后进先出”。

注意：堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域

---

## strlen 和 sizeof 的区别

* `sizeof` 是运算符，并不是函数，结果在编译时得到而非运行中获得；`strlen` 是字符处理的库函数
* `sizeof` 参数可以是任何数据的类型或者数据(`sizeof` 参数不退化)；`strlen` 的参数只能是字符指针且结尾是 `\0` 的字符串
* 因为 `sizeof` 值在编译时确定，所以不能用来得到动态分配(运行时分配)存储空间的大小

---

## malloc 和 new 的区别

* `malloc` 和 `free` 是标准库函数，支持覆盖；`new` 和 `delete` 是运算符，不重载
* `malloc` 仅仅分配内存空间，`free` 仅仅回收空间，不具备调用构造函数和析构函数功能，用 `malloc` 分配空间存储类的对象存在风险；`new` 和 `delete` 除了分配回收功能外，还会调用构造函数和析构函数
* `malloc` 和 `free` 返回的是 `void` 类型指针(必须进行类型转换)，`new` 和 `delete` 返回的是具体类型指针

---

## new/delete 和 malloc/free 的区别

相同点：都可用于内存的动态申请和释放

不同点：

* 前者是 C++ 运算符，后者是 C/C++ 语言标准库函数
* `new` 自动计算要分配的空间大小，`malloc` 需要手工计算
* `new` 是类型安全的，`malloc` 不是
* `new` 调用名为 `operator new` 的标准库函数分配足够空间并调用相关对象的构造函数，`delete` 对指针所指对象运行适当的析构函数；然后通过调用名为 `operator delete` 的标准库函数释放该对象所用内存。后者均没有相关调用
* 后者需要库文件支持，前者不用
* `new` 是封装了 `malloc`，直接 `free` 不会报错，但是这只是释放内存，而不会析构对象

既然有了 `malloc/free`，C++ 中为什么还需要 `new/delete` 呢？直接用 `malloc/free` 不好吗？

`malloc/free` 和 `new/delete` 都是用来申请内存和回收内存的
* 在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而 `malloc/free` 是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给 `malloc/free`，所以 `new/delete` 是必不可少的

---

## 宏定义和函数的区别

* 宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数
* 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值
* 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型
* 宏定义不要在最后加分号

---

## 宏定义和 typedef 的区别

* 宏主要用于定义常量及书写复杂的内容；`typedef` 主要用于定义类型别名
* 宏替换发生在编译阶段之前，属于文本插入替换；`typedef` 是编译的一部分
* 宏不检查类型；`typedef` 会检查数据类型
* 宏不是语句，不在在最后加分号；`typedef` 是语句，要加分号标识结束

注意对指针的操作，`typedef char * p_char` 和 `#define p_char char *` 区别巨大

---

## 变量声明和定义区别

* 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间
* 相同变量可以在多处声明(外部变量 `extern`)，但只能在一处定义

---

## 

---
