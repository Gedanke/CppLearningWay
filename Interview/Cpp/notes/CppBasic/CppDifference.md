# 区别篇

---

## C 和 C++ 区别

* C++ 是面向对象的语言，而 C 是面向过程的语言
* C++ 中的 xxx 取代了 C 中的 xxx
    * C++ 中的 `new` 和 `delete` 内存分配的运算符，取代了 C 中的 `malloc` 和 `free`
    * C++ 中的字符串类取代了标准 C 函数库头文件中的字符数组处理函数，C 中是没有字符串类型
    * C++ 中 `iostream` 类库替代了标准 C 中的 `stdio` 函数库
    * C++ 中的 `try/catch/throw` 异常处理机制取代了标准 C 中的 `setjmp()` 和 `longjmp()` 函数
* C++ 引入了 xxx，而 C 中没有或者不行
    * C++ 引入引用的概念，而 C 中没有
    * C++ 引入类的概念，而 C 中没有
    * C++ 引入函数重载的特性，而 C 中没有
    * C++ 引入了很多关键字，如：bool、using、dynamic_cast、namespace，而 C 中没有
    * C++ 中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而 C 语言中，必须要在函数开头部分。而且 C++ 不允许重复定义变量

---

## C++ 和 python 区别

* python 是脚本语言，是解释执行的，而 C++ 是编译语言，编译后在特定平台运行的，不他平台有不同编译器，不同的头文件等等。python 跨平台很方便，但效率不及 C++。当然 python 有些库在不同平台下的表现也会有一定差异，但总体比 C++ 好一些
* python 使用缩进来区分不同的代码块，C++ 使用花括号来区分
* C++ 定义变量需指定其类型，而 python 不需要，其基本数据类型只有数字，布尔值，字符串，列表，元组等等，当然 C++ 也可以使用 `auto` 让编译器自动推导
* python 库函数很多，安装，使用起来都比 C++ 方便得多

---

## C++ 与 Java 区别

* Java 语法更为简洁；完全面向对象，它的可移植性强
* Java 没有指针的概念，引入了真正的数组。不同于 C++ 中利用指针实现的“伪数组”，Java 引入了真正的数组，摒弃了指针这个概念，减少了 C++ 程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题。其实 STL 中的 `[]` 运算符访问元素越界编译器不会报错，而 `at()` 方法则会进行检查
* C++ 几乎可以在所有操作系统上运行，但是需要不同的编码，这一点不如 Java，只编写一次代码，到处运行，例如 C++ 的 `float` 与 `double` 在 windows 与 linux 上储存的空间不一样，Java 则是统一的
* Java 用接口(`Interface`)技术取代C++程序中的抽象类。接口与抽象类有同样的功能，但是省却了在实现和维护上的复杂性
* C++ 用析构函数回收垃圾，写 C 和 C++ 程序时一定要注意内存的申请和释放，主要是 `new` 操作，在堆上申请内存，而忘了释放或者重复释放；Java 没有指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题，但依然会有内存方面问题，如常见的空指针异常
* Java 在桌面程序上不如 C++，C++ 可以直接编译成 `exe` 文件，指针是 C++ 的优势，可以直接对内存的操作，但同时具有危险性
* Java 在 Web 应用上具有 C++ 无可比拟的优势，具有丰富多样的框架；对于底层程序的编程以及控制方面的编程，C++ 很灵活，因为有句柄的存在

---

## a 和 &a 区别

假设数组 `int a[5]; int (*p)[5] = &a;`，其中：

* `a` 是数组名，是数组首元素地址，`+1` 表示地址值加上一个 `int` 类型的大小，如果 `a` 的值是 `0x11111111`，加 1 操作后变为 `0x11111115`。`*(a + 1) = a[1]`
* `&a` 是数组的指针，其类型为 `int (*)[5]`(前面提到的数组指针)，其加 1 时，系统会认为是数组首地址加上整个数组的偏移(5 个 `int` 型变量)，值为数组 `a` 尾元素后一个元素的地址
* 若 `(int *)p` ，此时输出 `*p` 时，其值为 `a[0]` 的值，因为被转为 `int *` 类型，解引用时按照 `int` 类型大小来读取

---

## 指针和引用区别

* 指针是一个变量，存储的是地址，引用跟原变量是同一个东西，只是个别名
* 指针可以有多级，引用只有一级
* 指针可以为空，先定义后初始化，引用不能为 `NULL` 且在定义时必须初始化
* 指针在初始化后可以改变指向，而引用在初始化之后不可改变指向
* `sizeof` 指针得到的是本指针的大小，`sizeof` 引用得到的是引用所指向变量的大小
* 指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，指针需要被解引用才可以对对象进行操作，在函数中改变这个变量的指向不影响实参，而引用却可以，直接对引用的修改都会改变引用所指向的对象
* 引用本质是一个指针，同样会占 4 字节内存；指针是具体变量，需要占用存储空间，具体情况还要具体分析
* 不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针
* 指针和引用使用 `++` 运算符的意义不一样
* 如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露

---

## 常量指针和指针常量区别

区分的时候，看 `const` 与 `*` 的前后位置

* 指针常量是一个指针，指向一个只读变量，也就是后面所指明的 `int const` 和 `const int`，都是一个常量，可以写作 `int const *p` 或 `const int *p`
* 常量指针是一个不能给改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值就不能在改变了，即不能中途改变指向，如 `int *const p`，引用就是常量指针

---

## 堆区和栈区区别

* 申请方式
    * 栈资源由编译器自动管理，无需程序员手动处理
    * 堆中资源由程序员开辟与释放，存放函数的参数值，局部变量的值
* 内存管理机制，连续空间和连续空间的区别
    * 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出
    * 系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序(大多数系统会在这块内存空间首地址记录本次分配的大小，这样 `delete` 才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中)
* 空间大小
    * 栈是一块连续的内存区域，大小是操作系统预定好的，默认是 4M，可以通过 `ulimit -a` 查看，由 `ulimit -s` 修改
    * 堆是不连续的内存区域，堆大小受限于计算机系统中有效的虚拟内存，所以堆的空间比较灵活，比较大
* 碎片问题
    * 对于栈，它是类似于数据结构上的栈，进出一一对应，不会产生碎片
    * 对于堆，频繁的 `new/delete` 会造成大量碎片，使程序效率降低
* 生长方向
    * 栈向下，向低地址方向增长
    * 堆向上，向高地址方向增长
* 分配方式
    * 栈有静态分配和动态分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现
        * 静态分配由编译器完成(如局部变量分配)
        * 动态分配由 `alloca` 函数分配
    * 堆只是动态分配
* 分配效率
    * 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门寄存器存放栈地址，栈操作有专门指令
    * 堆由 C/C++ 函数库提供，机制很复杂。所以堆的效率比栈低很多

---

## 述队列和栈区别

队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同

* 队列是“先进先出”
* 栈是 “后进先出”。

注意：堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域

---

## strlen 和 sizeof 区别

* `sizeof` 是运算符，并不是函数，结果在编译时得到而非运行中获得；`strlen` 是字符处理的库函数
* `sizeof` 参数可以是任何数据的类型或者数据(`sizeof` 参数不退化)；`strlen` 的参数只能是字符指针且结尾是 `\0` 的字符串
* 因为 `sizeof` 值在编译时确定，所以不能用来得到动态分配(运行时分配)存储空间的大小

---

## malloc 和 new 区别

* `malloc` 和 `free` 是标准库函数，支持覆盖；`new` 和 `delete` 是运算符，不重载
* `malloc` 仅仅分配内存空间，`free` 仅仅回收空间，不具备调用构造函数和析构函数功能，用 `malloc` 分配空间存储类的对象存在风险；`new` 和 `delete` 除了分配回收功能外，还会调用构造函数和析构函数
* `malloc` 和 `free` 返回的是 `void` 类型指针(必须进行类型转换)，`new` 和 `delete` 返回的是具体类型指针

---

## new/delete 和 malloc/free 区别

相同点：都可用于内存的动态申请和释放

不同点：

* 前者是 C++ 运算符，后者是 C/C++ 语言标准库函数
* `new` 自动计算要分配的空间大小，`malloc` 需要手工计算
* `new` 是类型安全的，`malloc` 不是
* `new` 调用名为 `operator new` 的标准库函数分配足够空间并调用相关对象的构造函数，`delete` 对指针所指对象运行适当的析构函数；然后通过调用名为 `operator delete` 的标准库函数释放该对象所用内存。后者均没有相关调用
* 后者需要库文件支持，前者不用
* `new` 是封装了 `malloc`，直接 `free` 不会报错，但是这只是释放内存，而不会析构对象

既然有了 `malloc/free`，C++ 中为什么还需要 `new/delete` 呢？直接用 `malloc/free` 不好吗？

`malloc/free` 和 `new/delete` 都是用来申请内存和回收内存的
* 在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而 `malloc/free` 是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给 `malloc/free`，所以 `new/delete` 是必不可少的

---

## 宏定义和函数区别

* 宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数
* 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值
* 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型
* 宏定义不要在最后加分号

---

## 宏定义和 typedef 区别

* 宏主要用于定义常量及书写复杂的内容；`typedef` 主要用于定义类型别名
* 宏替换发生在编译阶段之前，属于文本插入替换；`typedef` 是编译的一部分
* 宏不检查类型；`typedef` 会检查数据类型
* 宏不是语句，不在在最后加分号；`typedef` 是语句，要加分号标识结束

注意对指针的操作，`typedef char * p_char` 和 `#define p_char char *` 区别巨大

---

## 变量声明和定义区别

* 声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间
* 相同变量可以在多处声明(外部变量 `extern`)，但只能在一处定义

---

## C 和 C++ struct 区别

C 语言中：`struct` 是用户自定义数据类型(UDT)；C++ 中 `struct` 是抽象数据类型(ADT)，支持成员函数的定义(C++ 中的 struct 能继承，能实现多态)

C 中 `struct` 是没有权限设置的，且 `struct` 中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员不可以是函数

C++ 中，`struct` 增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为 `public`(为了与 C 兼容)

`struct` 作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在 C 中必须在结构标记前加上 `struct`，才能做结构类型名(`typedef struct StructName{}Name;` 除外)；C++ 中结构体标记(结构体名)可以直接作为结构体类型名使用，此外结构体 `struct` 在 C++ 中被当作类的一种特例

---

## struct 和 class 区别

相同点

* 两者都拥有成员函数、公有和私有部分
* 任何可以使用 `class` 完成的工作，同样可以使用 `struct` 完成

不同点

* 两者中如果不对成员不指定公私有，`struct` 默认是公有的，`class` 则默认是私有的
* `class` 默认是 `private` 继承，而 `struct` 默认是 `public` 继承

---

## define 宏定义和 const 区别

编译阶段

* `define` 是在编译的预处理阶段起作用，而 `const` 是在编译、运行的时候起作用

安全性

* `define` 只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住全部的内容，要不然很容易出错
* `const` 常量有数据类型，编译器可以对其进行类型安全检查

内存占用

* `define` 只是将宏名称进行替换，在内存中会产生多分相同的备份。`const` 在程序运行中只有一份备份，且可以执行常量折叠，能将复杂的的表达式计算出结果放入常量表
* 宏替换发生在编译阶段之前，属于文本插入替换；`const` 作用发生于编译过程中
* 宏不检查类型；`const` 会检查数据类型
* 宏定义的数据没有分配内存空间，只是插入替换掉；`const` 定义的变量只是值不能改变，但要分配内存空间

---

## 顶层 const 和底层 const

* 顶层 `const`：指的是 `const` 修饰的变量本身是一个常量，无法修改，指的是指针，就是 `*` 号的右边
* 底层 `const`：指的是 `const` 修饰的变量所指向的对象是一个常量，指的是所指变量，就是 `*` 号的左边

举个例子

```c
int a = 10;
int *const b1 = &a;       // 顶层 const，b1 本身是一个常量
const int *b2 = &a;       // 底层 const，b2 本身可变，所指的对象是常量
const int b3 = 20;        // 顶层 const，b3 是常量不可变
const int *const b4 = &a; // 前一个 const 为底层，后一个为顶层，b4 不可变
const int &b5 = a;        // 用于声明引用变量，都是底层 const
```
    
区分作用

* 执行对象拷贝时有限制，常量的底层 `const` 不能赋值给非常量的底层 `const`
* 使用命名的强制类型转换函数 `const_cast` 时，只能改变运算对象的底层 `const`

```c
const int a;
int const a;
const int *a;
int *const a;
```
    
* `int const a` 和 `const int a` 均表示定义常量类型 `a`
* `const int *a`，其中 `a` 为指向 `int` 型变量的指针，`const` 在 `*` 左侧，表示 `a` 指向不可变常量(看成 `const (*a)`，对引用加 `const`)
* `int *const a`，依旧是指针类型，表示 `a` 为指向整型数据的常指针(看成 `const(a)`，对指针 `const`)

---

## 数组名和指针区别

* 二者均可通过增减偏移量来访问数组中的元素
* 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作
* 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但 `sizeof` 运算符不能再得到原数组的大小了

---

## 拷贝初始化和直接初始化区别

* 当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下

```c
string str1("I am a string");  //语句1 直接初始化
string str2(str1);             //语句2 直接初始化，str1 是已经存在的对象，直接调用拷贝构造函数对 str2 进行初始化
string str3 = "I am a string"; //语句3 拷贝初始化，先为字符串 "I am a string" 创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造 str3
string str4 = str1;            //语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数
```
    
* 为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化了(语句1 和语句3 等价)，但是需要辨别两种情况
    * 当拷贝构造函数为 `private` 时：语句3 和语句4 在编译时会报错
    * 使用 `explicit` 修饰构造函数时：如果构造函数存在隐式转换，编译时会报错

---

## 初始化和赋值区别

对于简单类型来说，初始化和赋值没什么区别
对于类和复杂数据类型来说，有区别，举例如下：

```c
#include <iostream>

using namespace std;

class A
{
public:
    int num1;
    int num2;

public:
    A(int a = 0, int b = 0) : num1(a), num2(b){};
    A(const A &a){};
    // 重载 = 号操作符函数
    A &operator=(const A &a)
    {
        num1 = a.num1 + 1;
        num2 = a.num2 + 1;
        return *this;
    };
};
int main()
{
    A a(1, 1);
    A a1 = a; // 拷贝初始化操作，调用拷贝构造函数
    A b;
    b = a; // 赋值操作，对象 a 中，num1 = 1，num2 = 1；对象 b 中，num1 = 2，num2 = 2
    return 0;
}
```

---

## 重载、重写(覆盖)和隐藏的区别

**重载(overload)**

重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。重载和函数成员是否是虚函数无关。举个例子：

```cpp
class A
{
    // ...
    virtual int fun();
    void fun(int);
    void fun(double, double);
    static int fun(char);
    // ...
};
```

**重写(覆盖)(override)**

重写指的是在派生类中覆盖基类中的同名函数，重写就是重写函数体，要求基类函数必须是虚函数且：

* 与基类的虚函数有相同的参数个数
* 与基类的虚函数有相同的参数类型
* 与基类的虚函数有相同的返回值类型

举个例子：

```cpp
// 父类
class A
{
public:
    virtual int fun(int a) {}
};

// 子类
class B : public A
{
public:
    // 重写，一般加 override 可以确保是重写父类的函数
    virtual int fun(int a) override {}
};
```

重载与重写的区别：

* 重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系
* 重写要求参数列表相同，重载则要求参数列表不同，返回值不要求
* 重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体

**隐藏(hide)**

隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：

* 两个函数参数相同，但是基类函数不是虚函数。**和重写的区别在于基类函数是否是虚函数**。举个例子：

```cpp
#include <iostream>

using namespace std;

// 父类
class A
{
public:
    void fun(int a)
    {
        cout << "A 中的 fun 函数" << endl;
    }
};

// 子类
class B : public A
{
public:
    // 隐藏父类的 fun 函数
    void fun(int a)
    {
        cout << "B 中的 fun 函数" << endl;
    }
};

int main()
{
    B b;
    b.fun(2);    // 调用的是 B 中的 fun 函数
    b.A::fun(2); // 调用 A 中 fun 函数

    /*
        B 中的 fun 函数
        A 中的 fun 函数
    */

    return 0;
}
```

* 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。举个例子：

```cpp
#include <iostream>

using namespace std;

// 父类
class A
{
public:
    virtual void fun(int a)
    {
        cout << "A 中的 fun 函数" << endl;
    }
};

// 子类
class B : public A
{
public:
    // 隐藏父类的 fun 函数
    virtual void fun(char *a)
    {
        cout << "A 中的 fun 函数" << endl;
    }
};

int main()
{
    B b;
    // b.fun(2); // 报错，调用的是 B 中的 fun 函数，参数类型不对
    b.A::fun(2); // 调用 A 中 fun 函数

    // A 中的 fun 函数

    return 0;
}
```

补充：

```cpp
#include <iostream>

using namespace std;

// 父类
class A
{
public:
    virtual void fun(int a)
    {
        // 虚函数
        cout << "This is A fun " << a << endl;
    }
    void add(int a, int b)
    {
        cout << "This is A add " << a + b << endl;
    }
};

// 子类
class B : public A
{
public:
    void fun(int a) override
    {
        // 覆盖
        cout << "This is B fun " << a << endl;
    }
    void add(int a)
    {
        // 隐藏
        cout << "This is B add " << a + a << endl;
    }
};

int main()
{
    // 基类指针指向派生类对象时，基类指针可以直接调用到派生类的覆盖函数，也可以通过 :: 调用到基类被覆盖
    // 的虚函数；而基类指针只能调用基类的被隐藏函数，无法识别派生类中的隐藏函数

    A *p = new B();
    p->fun(1);    // 调用子类 fun 覆盖函数
    p->A::fun(1); // 调用父类 fun
    p->add(1, 2);
    // p->add(1);      // 错误，识别的是 A 类中的 add 函数，参数不匹配
    // p->B::add(1);   // 错误，无法识别子类 add 函数

    /*
        This is B fun 1
        This is A fun 1
        This is A add 3
    */

    return 0;
}
```

---

## 浅拷贝和深拷贝的区别

* 浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误

* 深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的

```c
#include <iostream>
#include <string.h>
using namespace std;

class Student
{
private:
    int num;
    char *name;

public:
    Student()
    {
        name = new char(20);
        cout << "Student" << endl;
    }

    ~Student()
    {
        cout << "~Student " << &name << endl;
        delete name;
        name = NULL;
    }

    // 拷贝构造函数
    Student(const Student &s)
    {
        // 浅拷贝，当对象的 name 和传入对象的 name 指向相同的地址
        // name = s.name;
        // 深拷贝
        name = new char(20);
        memcpy(name, s.name, strlen(s.name));
        cout << "copy Student" << endl;
    }
};

int main()
{
    // 花括号让 s1 和 s2 变成局部对象，方便测试
    Student s1;
    Student s2(s1); // 复制对象

    // 浅拷贝
    /*
        Student
        copy Student
        ~Student 0x7fff616aa758
        ~Student 0x7fff616aa748
        free(): double free detected in tcache 2
        Aborted
    */

    // 深拷贝

    /*
        Student
        copy Student
        ~Student 0x7ffd37019ec8
        ~Student 0x7ffd37019eb8
    */

    return 0;
}
```

---

## 内联函数和宏定义区别

* 在使用时，宏只做简单字符串替换(编译前)。而内联函数可以进行参数类型检查(编译时)，且具有返回值
* 内联函数在编译时直接将函数代码嵌入到目标代码中，省去函数调用的开销来提高执行效率，并且进行参数类型检查，具有返回值，可以实现重载
* 宏定义时要注意书写(参数要括起来)否则容易出现歧义，内联函数不会产生歧义
* 内联函数有类型检测、语法判断等功能，而宏没有

内联函数适用场景:

* 使用宏定义的地方都可以使用 `inline` 函数
* 作为类成员接口函数来读写类的私有成员或者保护成员，会提高效率

---

## 形参与实参区别

* 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形参变量
* 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值，输入等办法使实参获得确定值，会产生一个临时变量
* 实参和形参在数量上，类型上，顺序上应严格一致，否则会发生“类型不匹配”的错误
* 函数调用中发生的数据传送是单向的。即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化
* 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变

---

## 全局变量和局部变量区别

* 生命周期不同
    * 全局变量随主程序创建和创建，随主程序销毁而销毁
    * 局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在
* 使用方式不同
    * 通过声明后全局变量在程序的各个部分都可以用到
    * 局部变量分配在堆栈区，只能在局部使用
* 操作系统和编译器通过内存分配的位置可以区分两者
    * 全局变量分配在全局数据段并且在程序开始运行的时候被加载
    * 局部变量则分配在堆栈里面 

---

## 指针参数传递和引用参数传递区别

* 指针参数传递本质上是值传递，它所传递的是一个地址值
    * 值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本
    * 值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值(形参指针变了，实参指针不会变)
* 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址
    * 被调函数对形参(本体)的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量(根据别名找到主调函数中的本体)
    * 因此，被调函数对形参的任何操作都会影响主调函数中的实参变量
* 引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量  
    * 而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量(地址)，那就得使用指向指针的指针(二级指针)或者指针引用
* 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址
    * 指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值(与实参名字不同，地址相同)
    * 符号表生成之后就不会再改，因此指针可以改变其指向的对象(指针变量中的值可以改)，而引用对象则不能修改

---

## const 与 #define 区别

* `const` 定义的常量是变量带类型，而 `#define` 定义的只是个常数不带类型
* `define` 只在预处理阶段起作用，简单的文本替换，而 `const` 在编译、链接过程中起作用
* `define` 只是简单的字符串替换没有类型检查。而 `const` 是有数据类型的，是要进行判断的，可以避免一些低级错误
* `define` 预处理后，占用代码段空间，`const` 占用数据段空间
* `const` 不能重定义，而 `define` 可以通过 `#undef` 取消某个符号的定义，进行重定义
* `define` 独特功能，比如可以用来防止文件重复引用

---

## define 与 inline 区别

* `#define` 是关键字，`inline` 是函数
* 宏定义在预处理阶段进行文本替换，`inline` 函数在编译阶段进行替换
* `inline` 函数有类型检查，相比宏定义比较安全

---

## cout 和 printf 区别

`cout<<` 是一个函数，`cout<<` 后可以跟不同的类型是因为 `cout<<` 已存在针对各种类型数据的重载，所以会自动识别数据的类型

输出过程会首先将输出字符放入缓冲区，然后输出到屏幕

`cout` 是有缓冲输出

```c
cout < < "abc " < <endl; 
```

等价于

```c
cout < < "abc\n "; 
cout < <flush;
```

`flush` 立即强迫缓冲输出

`printf` 是行缓冲输出，不是无缓冲输出

---

## 定义和声明区别

* 如果是指变量的声明和定义：从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存
* 如果是指函数的声明和定义：声明：一般在头文件里，让编译器知道这个函数的存在。定义：一般在源文件里，具体就是函数的实现过程写明函数体

---

## 全局变量和 static 变量区别

* 全局变量(外部变量)的说明之前再冠以 `static` 就构成了静态的全局变量

全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式

这两者在存储方式上并无不同。这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个原文件组成时，非静态的全局变量在各个源文件中都是有效的

而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其他源文件中引起错误

`static` 全局变量与普通的全局变量的区别是 `static` 全局变量只初始化一次，防止在其他文件单元被引用

---

## static 函数与普通函数区别

`static` 函数与普通的函数作用域不同。尽在本文件中。只在当前源文件中使用的函数应该说明为内部函数(`static`)，内部函数应该在当前源文件中说明和定义

对于可在当前源文件以外使用的函数应该在一个头文件中说明，要使用这些函数的源文件要包含这个头文件。`static` 函数与普通函数最主要区别是 `static` 函数在内存中只有一份，普通静态函数在每个被调用中维持一份拷贝程序的局部变量存在于堆栈中，全局变量存在于静态区中，动态申请数据存在于堆

---

## 静态成员与普通成员区别

* 生命周期
    * 静态成员变量从类被加载开始到类被卸载，一直存在
    * 普通成员变量只有在类创建对象后才开始存在，对象结束，它的生命期结束
* 共享方式
    * 静态成员变量是全类共享
    * 普通成员变量是每个对象单独享用的
* 定义位置
    * 普通成员变量存储在栈或堆中
    * 静态成员变量存储在静态全局区
* 初始化位置
    * 普通成员变量在类中初始化
    * 静态成员变量在类外初始化
* 默认实参
    * 可以使用静态成员变量作为默认实参

---

## strcpy 和 memcpy 区别

* 复制的内容不同
    * `strcpy` 只能复制字符串
    * `memcpy` 可以复制任意内容，例如字符数组、整型、结构体、类等
* 复制的方法不同
    * `strcpy` 不需要指定长度，它遇到被复制字符的串结束符 `\0` 才结束，所以容易溢出
    * `memcpy` 则是根据其第 3 个参数决定复制的长度
* 用途不同
    * 通常在复制字符串时用 `strcpy`
    * 需要复制其他类型数据时则一般用 `memcpy`

---

## const char* 与 string 区别

`string` 是 C++ 标准库里面其中一个，封装了对字符串的操作，实际操作过程可以用 `const char*` 给 `string` 类初始化

三者的转化关系如下所示：

* `string` 转 `const char*` 

```cpp
string s = "abc"; 
const char* c_s = s.c_str(); 
```

* `const char*` 转 `string`，直接赋值即可 

```cpp
const char* c_s = "abc"; 
string s(c_s); 
```

* `string` 转 `char*` 

```cpp
string s = "abc"; 
char* c; 
const int len = s.length(); 
c = new char[len+1]; 
strcpy(c, s.c_str()); 
```

* `char*` 转 `string` 

```cpp
char* c = "abc"; 
string s(c); 
```

* `const char*` 转 `char*` 
 
```cpp
const char* cpc = "abc"; 
char* pc = new char[strlen(cpc)+1]; 
strcpy(pc, cpc);
```

* `char*` 转 `const char*`，直接赋值即可 

```cpp
char* pc = "abc"; 
const char* cpc = pc;
```

---

## strcpy 和 strncpy 区别

```cpp
char* strcpy(char* strDest, const char* strSrc);
char *strncpy(char *dest, const char *src, size_t n);
```
    
* `strcpy` 函数: 如果参数 `dest` 所指的内存空间不够大，可能会造成缓冲溢出(buffer Overflow)的错误情况，在编写程序时请特别留意，或者用 `strncpy()` 来取代
* `strncpy` 函数：用来复制源字符串的前 `n` 个字符，`src` 和 `dest` 所指的内存区域不能重叠，且 `dest` 必须有足够的空间放置 `n` 个字符
    * 如果目标长 > 指定长 > 源长，则将源长全部拷贝到目标长，自动加上 `\0`
    * 如果指定长 < 源长，则将源长中按指定长度拷贝到目标字符串，不包括 `\0`
    * 如果指定长 > 目标长，运行时错误 

---

## malloc、realloc、calloc 区别

* `malloc` 函数

```cpp
void* malloc(unsigned int num_size);
int *p = malloc(20*sizeof(int)); // 申请 20 个 int 类型的空间
```

* `calloc` 函数

```cpp
void* calloc(size_t n,size_t size);
int *p = calloc(20, sizeof(int));
```

省去了人为空间计算；`malloc` 申请的空间的值是随机初始化的，`calloc` 申请的空间的值是初始化为 0 的

* `realloc` 函数

```cpp
void realloc(void *p, size_t new_size);
```
    
给动态分配的空间分配额外的空间，用于扩充容量

---

## 数组和指针的区别

* 数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：`sizeof(数组名)`；数组大小：`sizeof(数组名)/sizeof(数组元素数据类型)`
* 用运算符 `sizeof` 可以计算出数组的容量(字节数)。`sizeof(p)`，`p` 为指针得到的是一个指针变量的字节数，而不是 `p` 所指的内存容量
* 编译器为了简化对数组的支持，实际上是利用指针实现了对数组的支持。具体来说，就是将表达式中的数组元素引用转换为指针加偏移量的引用
* 在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去是数组的首地址而不是整个数组，能够提高效率
* 在使用下标的时候，两者的用法相同，都是原地址加上下标值，不过数组的原地址就是数组首元素的地址是固定的，指针的原地址就不是固定的

---

## delete 和 delete[] 区别

* `delete` 只会调用一次析构函数
* `delete[]` 会调用数组中每个元素的析构函数

---
