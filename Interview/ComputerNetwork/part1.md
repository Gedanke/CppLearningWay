# 第一部分

---

## OSI 的七层模型分别是？各自的功能是什么？

**简要概括**

* 物理层：底层数据传输，如网线；网卡标准
* 数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡 MAC 地址
* 网络层：定义IP编址，定义路由功能；如不同设备的数据转发
* 传输层：端到端传输数据的基本功能；如 TCP、UDP
* 会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件
* 表示层：数据格式标识，基本压缩加密功能
* 应用层：各种应用软件，包括 Web 应用

**说明**

* 在四层，既传输层数据被称作段(Segments)
* 三层网络层数据被称做包(Packages)
* 二层数据链路层时数据被称为帧(Frames)
* 一层物理层时数据被称为比特流(Bits)

**总结**

网络七层模型是一个标准，而非实现
网络四层模型是一个实现的应用模型
网络四层模型由七层模型简化合并而来

---

## HTTP 请求过程

* 建立起客户机和服务器连接
* 建立连接后，客户机发送一个请求给服务器
* 服务器收到请求给予响应信息
* 客户端浏览器将返回的内容解析并呈现，断开连接

或者

```sh
域名解析 --> 发起 TCP 的 3 次握手 --> 建立 TCP 连接后发起 http 请求 --> 服务器响应 http 请求，浏览器得到 html 代码 --> 浏览器解析 html 代码，并请求 html 代码中的资源(如js、css、图片等) --> 浏览器对页面进行渲染呈现给用户
```

---

## DNS 是什么

DNS(Domain Name System，域名系统)，因特网上作为域名和 IP 地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串

通过主机名，最终得到该主机名对应的 IP 地址的过程叫做域名解析或主机名解析

---

## DNS 工作原理

将主机域名转换为 ip 地址，属于应用层协议，使用 UDP 传输，DNS 应用层协议

过程：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存

* 主机向本地域名服务器的查询一般都是采用递归查询
* 本地域名服务器向根域名服务器的查询的迭代查询

当用户输入域名时
    * 浏览器先检查自己的缓存中是否包含这个域名映射的 ip 地址，有解析结束
    * 若没命中，则检查操作系统缓存(如 Windows 的 hosts)中有没有解析过的结果，有解析结束
    * 若无命中，则请求本地域名服务器解析(LDNS)
    * 若 LDNS 没有命中就直接跳到根域名服务器请求解析。根域名服务器返回给 LDNS 一个主域名服务器地址
    * 此时 LDNS 再发送请求给上一步返回的gTLD(通用顶级域)，接受请求的 gTLD 查找并返回这个域名对应的 Name Server 的地址
    * Name Server 根据映射关系表找到目标 ip，返回给 LDNS

LDNS 缓存这个域名和对应的 ip，把解析的结果返回给用户，用户根据 TTL 值缓存到本地系统缓存中，域名解析过程至此结束

---

## DNS 解析过程

* 请求一旦发起，先在浏览器找之前有没有缓存过的域名所对应的 ip 地址，有的话，直接跳过 dns 解析了，若是没有，就会找硬盘的 hosts 文件，看看有没有，有的话，直接找到 hosts 文件里面的 ip
* 如果本地的 hosts 文件没有能得到对应的 ip 地址，浏览器会发出一个 dns 请求到本地 dns 服务器，本地 dns 服务器一般都是你的网络接入服务器商提供
* 查询你输入的网址的 DNS 请求到达本地 DNS 服务器之后，本地 DNS 服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地 DNS 服务器还要向 DNS 根服务器进行查询
* 本地 DNS 服务器继续向域服务器发出请求，在这个例子中，请求的对象是 `.com` 域服务器。`.com` 域服务器收到请求之后，也不会直接返回域名和 IP 地址的对应关系，而是告诉本地 DNS 服务器，你的域名的解析服务器的地址
* 最后，本地 DNS 服务器向域名的解析服务器发出请求，这时就能收到一个域名和 IP 地址对应关系，本地 DNS 服务器不仅要把 IP 地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问

---

## DNS 负载均衡

当一个网站用户过多时，假如每次请求的资源都位于同一台机器上面，那么这台机器负载会很高。处理办法就是用 DNS 负载均衡技术，它的原理是在 DNS 服务器中为同一个主机名配置多个 IP 地址，在应答 DNS 查询时，DNS 服务器对每个查询将以 DNS 文件中主机记录的 IP 地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等

---

## DNS 为什么用 UDP

其实 DNS 的整个过程是既使用 TCP 又使用 UDP

当进行区域传送(主域名服务器向辅助域名服务器传送变化的那部分数据)时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP

当客户端向 DNS 服务器查询域名(域名解析)时，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节。用 UDP 传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性

---

## DNS 劫持

DNS 劫持即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式。域名劫持往往只能在特定的网络范围内进行，范围外的 DNS 服务器能够返回正常的 IP 地址。攻击者可以冒充原域名所属机构，通过电子邮件的方式修改组织机构的域名注册信息，或者将域名转让给其它组织，并将新的域名信息保存在所指定的 DNS 服务器中，从而使得用户无法通过对原域名进行解析来访问目的网址

具体实施步骤如下：

* 获取要劫持的域名信息：攻击者首先会访问域名查询站点查询要劫持的域名信息
* 控制域名相应的 E-MAIL 账号：在获取到域名信息后，攻击者通过暴力破解或者专门的方法破解公司注册域名时使用的 E-mail 账号所对应的密码。更高级的攻击者甚至能够直接对 E-mail 进行信息窃取
* 修改注册信息：当攻击者破解了 E-MAIL 后，会利用相关的更改功能修改该域名的注册信息，包括域名拥有者信息，DNS 服务器信息等
* 使用 E-MAIL 收发确认函：在修改完注册信息后，攻击者在 E-mail 真正拥有者之前收到修改域名注册信息的相关确认信息，并回复确认修改文件，待网络公司恢复已成功修改信件后，攻击者便成功完成 DNS 劫持

用户端的一些预防手段：

* 直接通过 IP 地址访问网站，避开 DNS 劫持
* 由于域名劫持往往只能在特定的网络范围内进行，因此一些高级用户可以通过网络设置让 DNS 指向正常的域名服务器以实现对目的网址的正常访问，例如将计算机首选 DNS 服务器的地址固定为 `8.8.8.8`

---

## Cookie

HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务，HTTP/1.1 引入 Cookie 来保存状态信息

Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销(尤其是在移动环境下)

Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰

新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API(本地存储和会话存储)或 IndexedDB

cookie 的出现是因为 HTTP 是无状态的一种协议，换句话说，服务器记不住你，可能你每刷新一次网页，就要重新输入一次账号密码进行登录。这显然是让人无法接受的，cookie 的作用就好比服务器给你贴个标签，然后你每次向服务器再发请求时，服务器就能够 cookie 认出你

抽象地概括一下：一个 cookie 可以认为是一个变量，形如 `name = value`，存储在浏览器；一个 session 可以理解为一种数据结构，多数情况是映射(键值对)，存储在服务器上

---

## Cookie 的用途

* 会话状态管理(如用户登录状态、购物车、游戏分数或其它需要记录的信息)
* 个性化设置(如用户自定义设置、主题等)
* 浏览器行为跟踪(如跟踪分析用户行为等)

---

## Session

除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全

Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高

使用 Session 维护用户登录状态的过程如下：

* 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中
* 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID
* 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中
* 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作

注意：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式

---

## Session 工作原理

session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了

---

## 如何使用 Session

过程如下：

* 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中
* 服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID
* 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中
* 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作

注意：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式

---

## Cookie 与 Session

HTTP 作为无状态协议，必然需要在某种方式保持连接状态。这里简要介绍一下 Cookie 和 Session

* Cookie

Cookie 是客户端保持状态的方法

Cookie 简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将 Cookie 字符串放在 Set-Cookie 下，客户机收到 Cookie 之后保存这段字符串，之后再请求时候带上 Cookie 就可以被识别

除了上面提到的这些，Cookie 在客户端的保存形式可以有两种，一种是会话 Cookie；一种是持久 Cookie

会话 Cookie 就是将服务器返回的 Cookie 字符串保持在内存中，关闭浏览器之后自动销毁，持久 Cookie 则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的 Cookie 是可以被多个浏览器代理所共享的

* Session

Session 是服务器保持状态的方法

首先需要明确的是，Session 保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的 Session 用户在客户端上记录用户的操作。我们可以理解为每个用户有一个独一无二的 Session ID 作为 Session 文件的 Hash 键，通过这个值可以锁定具体的 Session 结构的数据，这个 Session 结构中存储了用户操作行为

当服务器需要识别客户端时就需要结合 Cookie 了。每次 HTTP 请求的时候，客户端都会发送相应的 Cookie 信息到服务端。实际上大多数的应用都是用 Cookie 来实现 Session 跟踪的，第一次创建 Session 的时候，服务端会在 HTTP 协议中告诉客户端，需要在 Cookie 里面记录一个 Session ID，以后每次请求把这个会话 ID 发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了 Cookie，会使用一种叫做 URL 重写的技术来进行会话跟踪，即每次 HTTP 交互，URL后 面都会被附加上一个诸如 `sid=xxxxx` 这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了

---

## Session 和 cookie 如何去选择

* Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session
* Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密
* 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中

---

## Cookies 和 Session 区别

Cookie 和 Session 都是客户端与服务器之间保持状态的解决方案

* 存储的位置不同，cookie：存放在客户端，session：存放在服务端。Session存储的数据比较安全
* 存储的数据类型不同，两者都是 `key-value` 的结构，但针对 `value` 的类型是有差异的。cookie：`value` 只能是字符串类型，session：`value` 是 `Object` 类型
* 存储的数据大小限制不同，cookie：大小受浏览器的限制，很多是 4K 的大小，session：理论上受当前内存的限制
* 生命周期的控制，cookie 生命周期当浏览器关闭的时候，就消亡了
    * cookie 生命周期是累计的，从创建时，就开始计时，如20 分钟后，cookie 生命周期结束， * session 生命周期是间隔的，从创建时，开始计时如在 20 分钟，没有访问 session，那么 session 生命周期被销毁

---






---
