# 位运算

我们可以使用 C 对变量中的个别位进行操作，C 提供位的逻辑运算符和移位运算符。在之后的例子中将使用二进制计数法写出值，以便更好地体现位运算的具体过程，并使用 8 位数字，从左到右，每位的编号是 0-7

---

## 位逻辑运算符

C 中有 4 个位运算符用于整型数据，包括 `char`。将这些位运算符成为位运算的原因是它们对每位进行操作，而不影响左右两侧的位，常规的位逻辑运算符对整个值进行操作

### 按位取反 ~

一元运算符 `~` 将每个 1 变为 0，将每个 0 变为 1

```c
~(10011010) => 01100101
```

假设 `a` 是一个 `unsigned char`，已赋值为 2，二进制表示为 00000010，于是 `~a` 的值为 11111101 或者 253。请注意该运算符不会改变 `a` 的值，`a` 仍为 2

```c
unsigned char a = 2;     // 00000010
unsigned char b = ~a;    // 11111101
printf("ret = %d\n", a); // ret = 2
printf("ret = %d\n", b); // ret = 253
```

### 位与(AND) &

运算符 `&` 通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都是 1 时结果才为 1

```c
(10010011) 
& 
(00111101) 
=
(00010001)
```

C 也有一个组合的位与赋值运算符：`&=`

```c
val &= 0377;
val = val & 0377;
```

这俩是等价的

### 位或(OR) |

运算符 `|` 通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为 1，那么结果位就为 1

```c
(10010011)
|
(00111101)
=
(10111111)
```

C 也有组合位或赋值运算符：`|=`

```c
val |= 0377;
val = val | 0377;
```

### 位异或 ^

运算符 `^` 对两个操作数逐位进行比较。对于每个位，如果操作数中的对应位有一个是 1(但不是都是 1)，那么结果是 1；如果都是 0 或者都是 1，则结果位 0

```c
(10010011)
^
(00111101)
=
(10101110)
```

C 也有一个组合的位异或-赋值运算符：`^=`

```c
val ^= 0377;
val = val ^ 0377;
```

### 用法

已知：

```c
flag = 10011010
```

* 将位 2 打开，`flag | 00000100`

```c
(10011010)
|
(00000100)
=
(10011110)
```

* 将所有位打开，`flag | ~flag`

```c
(10011010)
|
(01100101)
=
(11111111)
```

* 关闭位，`flag & ~flag`

```c
(10011010)
&
(01100101)
=
(00000000)
```

* 转置位，`flag ^ 0xff`，`flag ^ 0x00`

转置(toggling)一个位表示如果该位打开，则关闭该位；如果该位关闭，则打开

可以使用位异或运算符来转置。其思想是如果 `b` 是一个位，那么如果 `b` 为 1 则 `b^1` 为 0，如果 `b` 为 0，则 `1^b` 为 1。无论 b 的值是 0 还是 1，`0^b` 为 `b` 

```c
(10010011)
^
(11111111)
=
(01101100)
```

```c
(10010011)
^
(00000000)
=
(10010011)
```

* 交换两个数不需要临时变量

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    int num1 = 5;
    int num2 = 9;

    printf("num1 = %d\n", num1);
    printf("num2 = %d\n", num2);

    int tmp = num1;
    num1 = num2;
    num2 = tmp;

    printf("num1 = %d\n", num1);
    printf("num2 = %d\n", num2);

    num1 = num1 ^ num2;
    num2 = num1 ^ num2;
    num1 = num1 ^ num2;

    printf("num1 = %d\n", num1);
    printf("num2 = %d\n", num2);

    num1 = num1 + num2;
    num2 = num1 - num2;
    num1 = num1 - num2;

    printf("num1 = %d\n", num1);
    printf("num2 = %d\n", num2);

    /*
        num1 = 5
        num2 = 9
        num1 = 9
        num2 = 5
        num1 = 5
        num2 = 9
        num1 = 9
        num2 = 5
    */

    return 0;
}
```

---

## 移位运算符

移位运算符将位向左或向右移动，这里仍将明确地使用二进制形式来说明该机制的工作原理

### 左移 <<

左移运算符 `<<` 将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出来的位用 0 填充，并且丢弃移出左侧操作数末端的位

```c
(10001010) << 2
=
(00101000)
```

该操作将产生一个新位置，但是不改变其操作数

```c
1 << 1 = 2;
2 << 1 = 4;
4 << 1 = 8;
8 << 2 = 32;
```

左移一位相当于 `原值*2`

### 右移 >>

右移运算符 `>>` 将其左侧的操作数的值每位向右移动，移动的位数由其右侧的操作数指定。丢弃移出左侧操作数有段的位。对于 `unsigned` 类型，使用 0 填充左端空出的位。对于有符号类型，结果依赖于机器。空出的位可能用 0 填充，或者使用符号(最左端)位的副本填充

```c
// 有符号值
(10001010) >> 2
=
(00100010)     // 在某些系统上的结果值

(10001010) >> 2
=
(11100010)     // 在另一些系统上的结果

// 无符号值
(10001010) >> 2
=
(00100010)    // 所有系统上的结果值
```

左移一位相当于 `原值/2`

### 移位运算符用法

移位运算符能够提供快捷、高效(依赖于硬件)对 2 的幂乘法和除法

* `number << n`，`number` 乘以 2 的 `n` 次幂
* `number >> n`，如果 `number` 非负，则用 `number` 除以 2 的 `n` 次幂

![](../photos/part3/%E4%BD%8D%E8%BF%90%E7%AE%97.png)

---
